package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"

	"github.com/shennawardana23/graphql-pba/graph/generated"
	"github.com/shennawardana23/graphql-pba/graph/model"
	"github.com/shennawardana23/graphql-pba/internal/entity"
	"github.com/shennawardana23/graphql-pba/internal/util/exception"
	"github.com/shennawardana23/graphql-pba/internal/util/validation_model"
	"github.com/shennawardana23/graphql-pba/internal/util/validator"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// Convert to validation model and validate
	validationInput := validation_model.NewUserFromGQL(input)
	v := validator.New()
	if err := v.ValidateStruct(validationInput); err != nil {
		return nil, err
	}

	// Check for duplicate email
	exists, err := r.UserRepository.ExistsByEmail(ctx, input.Email)
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if exists {
		return nil, exception.ErrDuplicateEmail
	}

	user := &entity.User{
		Name:  input.Name,
		Email: input.Email,
	}

	if err := r.UserRepository.Create(ctx, user); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.User{
		ID:    int(user.ID),
		Name:  user.Name,
		Email: user.Email,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	// Validate input
	v := validator.New()
	if err := v.ValidateStruct(input); err != nil {
		return nil, err
	}

	// Check if user exists
	existingUser, err := r.UserRepository.FindByID(ctx, int64(input.ID))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if existingUser == nil {
		return nil, exception.ErrNotFound
	}

	// Check for email uniqueness if email is being updated
	if input.Email != nil && *input.Email != existingUser.Email {
		exists, err := r.UserRepository.ExistsByEmail(ctx, *input.Email)
		if err != nil {
			return nil, exception.ErrInternalServer
		}
		if exists {
			return nil, exception.ErrDuplicateEmail
		}
	}

	// Update fields if provided
	if input.Name != nil {
		existingUser.Name = *input.Name
	}
	if input.Email != nil {
		existingUser.Email = *input.Email
	}

	if err := r.UserRepository.Update(ctx, existingUser); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.User{
		ID:    int(existingUser.ID),
		Name:  existingUser.Name,
		Email: existingUser.Email,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id int) (*model.User, error) {
	// Validate ID
	if id <= 0 {
		return nil, exception.NewCustomError(
			"INVALID_ID",
			"Invalid user ID",
			"User ID must be a positive number",
		)
	}

	// Check if user exists
	existingUser, err := r.UserRepository.FindByID(ctx, int64(id))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if existingUser == nil {
		return nil, exception.ErrNotFound
	}

	// Delete user
	if err := r.UserRepository.Delete(ctx, int64(id)); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.User{ID: id}, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.UserRepository.FindAll(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, u := range users {
		result = append(result, &model.User{
			ID:    int(u.ID),
			Name:  u.Name,
			Email: u.Email,
		})
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id int) (*model.User, error) {
	// Validate ID
	if id <= 0 {
		return nil, exception.NewCustomError(
			"INVALID_ID",
			"Invalid user ID",
			"User ID must be a positive number",
		)
	}

	user, err := r.UserRepository.FindByID(ctx, int64(id))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if user == nil {
		return nil, exception.ErrNotFound
	}

	return &model.User{
		ID:    int(user.ID),
		Name:  user.Name,
		Email: user.Email,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
