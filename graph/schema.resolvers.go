package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.40

import (
	"context"

	"github.com/shennawardana23/graphql-pba/graph/generated"
	"github.com/shennawardana23/graphql-pba/graph/model"
	"github.com/shennawardana23/graphql-pba/internal/entity"
	"github.com/shennawardana23/graphql-pba/internal/util/exception"
	"github.com/shennawardana23/graphql-pba/internal/util/helper"
	"github.com/shennawardana23/graphql-pba/internal/util/validation_model"
	"github.com/shennawardana23/graphql-pba/internal/util/validator"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	// Convert to validation model and validate
	validationInput := validation_model.NewUserFromGQL(input)
	v := validator.New()
	if err := v.ValidateStruct(validationInput); err != nil {
		return nil, err
	}

	// Check for duplicate email
	exists, err := r.UserRepository.ExistsByEmail(ctx, input.Email)
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if exists {
		return nil, exception.ErrDuplicateEmail
	}

	user := &entity.User{
		Name:  input.Name,
		Email: input.Email,
	}

	if err := r.UserRepository.Create(ctx, user); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.User{
		ID:    int(user.ID),
		Name:  user.Name,
		Email: user.Email,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserInput) (*model.User, error) {
	// Validate input
	v := validator.New()
	if err := v.ValidateStruct(input); err != nil {
		return nil, err
	}

	// Check if user exists
	existingUser, err := r.UserRepository.FindByID(ctx, int64(input.ID))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if existingUser == nil {
		return nil, exception.ErrNotFound
	}

	// Check for email uniqueness if email is being updated
	if input.Email != nil && *input.Email != existingUser.Email {
		exists, err := r.UserRepository.ExistsByEmail(ctx, *input.Email)
		if err != nil {
			return nil, exception.ErrInternalServer
		}
		if exists {
			return nil, exception.ErrDuplicateEmail
		}
	}

	// Update fields if provided
	if input.Name != nil {
		existingUser.Name = *input.Name
	}
	if input.Email != nil {
		existingUser.Email = *input.Email
	}

	if err := r.UserRepository.Update(ctx, existingUser); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.User{
		ID:    int(existingUser.ID),
		Name:  existingUser.Name,
		Email: existingUser.Email,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id int) (*model.User, error) {
	// Validate ID
	if id <= 0 {
		return nil, exception.NewCustomError(
			"INVALID_ID",
			"Invalid user ID",
			"User ID must be a positive number",
		)
	}

	// Check if user exists
	existingUser, err := r.UserRepository.FindByID(ctx, int64(id))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if existingUser == nil {
		return nil, exception.ErrNotFound
	}

	// Delete user
	if err := r.UserRepository.Delete(ctx, int64(id)); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.User{ID: id}, nil
}

// CreateRestaurant is the resolver for the createRestaurant field.
func (r *mutationResolver) CreateRestaurant(ctx context.Context, input model.NewRestaurant) (*model.Restaurant, error) {
	restaurant := &entity.Restaurant{
		UserID:             int64(*input.UserID),
		RestaurantName:     input.RestaurantName,
		RestaurantLogo:     input.RestaurantLogo,
		RestaurantFavicon:  *input.RestaurantFavicon,
		ThumbnailDesktop:   input.ThumbnailDesktop,
		RestaurantPhone:    *input.RestaurantPhone,
		RestaurantWhatsapp: *input.RestaurantWhatsapp,
		RestaurantEmail:    *input.RestaurantEmail,
		RestaurantAddress:  *input.RestaurantAddress,
		RestaurantWebsite:  *input.RestaurantWebsite,
	}

	if err := r.RestaurantRepository.Create(ctx, restaurant); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.Restaurant{
		ID:                 int(restaurant.ID),
		UserID:             helper.Int64ToIntPtr(&restaurant.UserID),
		RestaurantName:     restaurant.RestaurantName,
		RestaurantLogo:     restaurant.RestaurantLogo,
		RestaurantFavicon:  &restaurant.RestaurantFavicon,
		ThumbnailDesktop:   restaurant.ThumbnailDesktop,
		RestaurantPhone:    &restaurant.RestaurantPhone,
		RestaurantWhatsapp: &restaurant.RestaurantWhatsapp,
		RestaurantEmail:    &restaurant.RestaurantEmail,
		RestaurantAddress:  &restaurant.RestaurantAddress,
		RestaurantWebsite:  &restaurant.RestaurantWebsite,
	}, nil
}

// UpdateRestaurant is the resolver for the updateRestaurant field.
func (r *mutationResolver) UpdateRestaurant(ctx context.Context, input model.UpdateRestaurantInput) (*model.Restaurant, error) {
	restaurant, err := r.RestaurantRepository.FindByID(ctx, int64(input.ID))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if restaurant == nil {
		return nil, exception.ErrNotFound
	}

	// Update fields if provided
	if input.UserID != nil {
		restaurant.UserID = int64(*input.UserID)
	}
	if input.RestaurantName != nil {
		restaurant.RestaurantName = *input.RestaurantName
	}
	if input.RestaurantLogo != nil {
		restaurant.RestaurantLogo = *input.RestaurantLogo
	}
	if input.RestaurantFavicon != nil {
		restaurant.RestaurantFavicon = *input.RestaurantFavicon
	}
	if input.ThumbnailDesktop != nil {
		restaurant.ThumbnailDesktop = *input.ThumbnailDesktop
	}
	if input.RestaurantPhone != nil {
		restaurant.RestaurantPhone = *input.RestaurantPhone
	}
	if input.RestaurantWhatsapp != nil {
		restaurant.RestaurantWhatsapp = *input.RestaurantWhatsapp
	}
	if input.RestaurantEmail != nil {
		restaurant.RestaurantEmail = *input.RestaurantEmail
	}
	if input.RestaurantAddress != nil {
		restaurant.RestaurantAddress = *input.RestaurantAddress
	}
	if input.RestaurantWebsite != nil {
		restaurant.RestaurantWebsite = *input.RestaurantWebsite
	}

	if err := r.RestaurantRepository.Update(ctx, restaurant); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.Restaurant{
		ID:                 int(restaurant.ID),
		UserID:             helper.Int64ToIntPtr(&restaurant.UserID),
		RestaurantName:     restaurant.RestaurantName,
		RestaurantLogo:     restaurant.RestaurantLogo,
		RestaurantFavicon:  &restaurant.RestaurantFavicon,
		ThumbnailDesktop:   restaurant.ThumbnailDesktop,
		RestaurantPhone:    &restaurant.RestaurantPhone,
		RestaurantWhatsapp: &restaurant.RestaurantWhatsapp,
		RestaurantEmail:    &restaurant.RestaurantEmail,
		RestaurantAddress:  &restaurant.RestaurantAddress,
		RestaurantWebsite:  &restaurant.RestaurantWebsite,
	}, nil
}

// DeleteRestaurant is the resolver for the deleteRestaurant field.
func (r *mutationResolver) DeleteRestaurant(ctx context.Context, id int) (*model.Restaurant, error) {
	restaurant, err := r.RestaurantRepository.FindByID(ctx, int64(id))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if restaurant == nil {
		return nil, exception.ErrNotFound
	}

	if err := r.RestaurantRepository.Delete(ctx, int64(id)); err != nil {
		return nil, exception.ErrInternalServer
	}

	return &model.Restaurant{ID: id}, nil
}

// Mutation to get restaurants by user ID
func (r *mutationResolver) RestaurantsByUserID(ctx context.Context, userID int) ([]*model.Restaurant, error) {
	var restaurants []entity.Restaurant
	err := r.RestaurantRepository.WithContext(ctx).
		Model(&restaurants).
		Relation("User").
		Where("user_id = ?", userID).
		Select()
	if err != nil {
		return nil, exception.TranslatePostgresError(ctx, err)
	}

	var result []*model.Restaurant
	for _, restaurant := range restaurants {
		result = append(result, &model.Restaurant{
			ID:                 int(restaurant.ID),
			UserID:             helper.Int64ToIntPtr(&restaurant.UserID),
			RestaurantName:     restaurant.RestaurantName,
			RestaurantLogo:     restaurant.RestaurantLogo,
			RestaurantFavicon:  &restaurant.RestaurantFavicon,
			ThumbnailDesktop:   restaurant.ThumbnailDesktop,
			RestaurantPhone:    &restaurant.RestaurantPhone,
			RestaurantWhatsapp: &restaurant.RestaurantWhatsapp,
			RestaurantEmail:    &restaurant.RestaurantEmail,
			RestaurantAddress:  &restaurant.RestaurantAddress,
			RestaurantWebsite:  &restaurant.RestaurantWebsite,
			User: &model.User{
				ID:    int(restaurant.User.ID),
				Name:  restaurant.User.Name,
				Email: restaurant.User.Email,
			},
		})
	}
	return result, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	users, err := r.UserRepository.FindAll(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.User
	for _, u := range users {
		result = append(result, &model.User{
			ID:    int(u.ID),
			Name:  u.Name,
			Email: u.Email,
		})
	}
	return result, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id int) (*model.User, error) {
	// Validate ID
	if id <= 0 {
		return nil, exception.NewCustomError(
			"INVALID_ID",
			"Invalid user ID",
			"User ID must be a positive number",
		)
	}

	user, err := r.UserRepository.FindByID(ctx, int64(id))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if user == nil {
		return nil, exception.ErrNotFound
	}

	return &model.User{
		ID:    int(user.ID),
		Name:  user.Name,
		Email: user.Email,
	}, nil
}

// Restaurants is the resolver for the restaurants field.
func (r *queryResolver) Restaurants(ctx context.Context) ([]*model.Restaurant, error) {
	restaurants, err := r.RestaurantRepository.FindAll(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.Restaurant
	for _, r := range restaurants {
		result = append(result, &model.Restaurant{
			ID:                 int(r.ID),
			UserID:             helper.Int64ToIntPtr(&r.UserID),
			RestaurantName:     r.RestaurantName,
			RestaurantLogo:     r.RestaurantLogo,
			RestaurantFavicon:  &r.RestaurantFavicon,
			ThumbnailDesktop:   r.ThumbnailDesktop,
			RestaurantPhone:    &r.RestaurantPhone,
			RestaurantWhatsapp: &r.RestaurantWhatsapp,
			RestaurantEmail:    &r.RestaurantEmail,
			RestaurantAddress:  &r.RestaurantAddress,
			RestaurantWebsite:  &r.RestaurantWebsite,
		})
	}
	return result, nil
}

// Restaurant is the resolver for the restaurant field.
func (r *queryResolver) Restaurant(ctx context.Context, id int) (*model.Restaurant, error) {
	restaurant, err := r.RestaurantRepository.FindByID(ctx, int64(id))
	if err != nil {
		return nil, exception.ErrInternalServer
	}
	if restaurant == nil {
		return nil, exception.ErrNotFound
	}

	return &model.Restaurant{
		ID:                 int(restaurant.ID),
		UserID:             helper.Int64ToIntPtr(&restaurant.UserID),
		RestaurantName:     restaurant.RestaurantName,
		RestaurantLogo:     restaurant.RestaurantLogo,
		RestaurantFavicon:  &restaurant.RestaurantFavicon,
		ThumbnailDesktop:   restaurant.ThumbnailDesktop,
		RestaurantPhone:    &restaurant.RestaurantPhone,
		RestaurantWhatsapp: &restaurant.RestaurantWhatsapp,
		RestaurantEmail:    &restaurant.RestaurantEmail,
		RestaurantAddress:  &restaurant.RestaurantAddress,
		RestaurantWebsite:  &restaurant.RestaurantWebsite,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
